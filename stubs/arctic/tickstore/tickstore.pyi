from .._util import indent as indent
from ..date import CLOSED_CLOSED as CLOSED_CLOSED, DateRange as DateRange, datetime_to_ms as datetime_to_ms, mktz as mktz, ms_to_datetime as ms_to_datetime, to_dt as to_dt, to_pandas_closed_closed as to_pandas_closed_closed, utc_dt_to_local_dt as utc_dt_to_local_dt
from ..decorators import mongo_retry as mongo_retry
from ..exceptions import ArcticException as ArcticException, NoDataFoundException as NoDataFoundException, OverlappingDataException as OverlappingDataException, UnhandledDtypeException as UnhandledDtypeException, UnorderedDataException as UnorderedDataException
from _typeshed import Incomplete

lz4_compressHC: Incomplete
PD_VER: Incomplete
logger: Incomplete
TICK_STORE_TYPE: str
ID: str
SYMBOL: str
INDEX: str
START: str
END: str
START_SEQ: str
END_SEQ: str
SEGMENT: str
SHA: str
IMAGE_DOC: str
IMAGE: str
COLUMNS: str
DATA: str
DTYPE: str
IMAGE_TIME: str
ROWMASK: str
COUNT: str
VERSION: str
META: str
CHUNK_VERSION_NUMBER: int

class TickStore:
    @classmethod
    def initialize_library(cls, arctic_lib, **kwargs) -> None: ...
    def _ensure_index(self) -> None: ...
    _arctic_lib: Incomplete
    _allow_secondary: Incomplete
    _chunk_size: Incomplete
    def __init__(self, arctic_lib, chunk_size: int = ...) -> None: ...
    _collection: Incomplete
    _metadata: Incomplete
    def _reset(self) -> None: ...
    def __getstate__(self): ...
    def __setstate__(self, state): ...
    def __str__(self): ...
    def __repr__(self): ...
    def delete(self, symbol, date_range: Incomplete | None = ...): ...
    def list_symbols(self, date_range: Incomplete | None = ...): ...
    def _mongo_date_range_query(self, symbol, date_range): ...
    def _symbol_query(self, symbol): ...
    def _read_preference(self, allow_secondary): ...
    def read(self, symbol, date_range: Incomplete | None = ..., columns: Incomplete | None = ..., include_images: bool = ..., allow_secondary: Incomplete | None = ..., _target_tick_count: int = ...): ...
    def read_metadata(self, symbol): ...
    def _pad_and_fix_dtypes(self, cols, column_dtypes): ...
    def _set_or_promote_dtype(self, column_dtypes, c, dtype) -> None: ...
    def _prepend_image(self, document, im, rtn_length, column_dtypes, column_set, columns): ...
    def _read_bucket(self, doc, column_set, column_dtypes, include_symbol, include_images, columns): ...
    def _empty(self, length, dtype): ...
    def stats(self): ...
    def _assert_nonoverlapping_data(self, symbol, start, end) -> None: ...
    def write(self, symbol, data, initial_image: Incomplete | None = ..., metadata: Incomplete | None = ...) -> None: ...
    def _write(self, buckets) -> None: ...
    def _pandas_to_buckets(self, x, symbol, initial_image): ...
    def _to_buckets(self, x, symbol, initial_image): ...
    @staticmethod
    def _to_ms(date): ...
    @staticmethod
    def _str_dtype(dtype): ...
    @staticmethod
    def _ensure_supported_dtypes(array): ...
    @staticmethod
    def _pandas_compute_final_image(df, image, end): ...
    @staticmethod
    def _pandas_to_bucket(df, symbol, initial_image): ...
    @staticmethod
    def _to_bucket(ticks, symbol, initial_image): ...
    def max_date(self, symbol): ...
    def min_date(self, symbol): ...
