from datetime import datetime, timezone
from typing import Literal
from zoneinfo import ZoneInfo

import ib_insync as ibi
import pytest

from haymaker.misc import (
    Counter,
    contractAsTuple,
    general_to_specific_contract_class,
    hash_contract,
    is_active,
    next_active,
    process_trading_hours,
    sign,
)


def test_Counter():
    c = Counter()
    num = c()
    assert isinstance(num, str)
    assert num.endswith("00000")


def test_Counter_increments_by_one():
    c = Counter()
    num = c()
    num1 = c()
    assert int(num1[-1]) - int(num[-1]) == 1


def test_Counter_doesnt_duplicate_on_reinstantiation():
    c = Counter()
    num = c()
    d = Counter()
    num1 = d()
    assert num != num1


@pytest.mark.parametrize(
    "input,expected",
    [(0, 0), (5, 1), (-10, -1), (-3.4, -1), (2.234, 1), (-0, 0), (+0, 0), (-0.0000, 0)],
)
def test_sign_function(input: float | Literal[0] | Literal[5] | Literal[-10], expected):
    assert sign(input) == expected


trading_hours_string = "20231016:1700-20231017:1600;20231017:1700-20231018:1600;20231018:1700-20231019:1600;20231019:1700-20231020:1600;20231021:CLOSED;20231022:1700-20231023:1600"  # noqa


def test_process_trading_hours_returns_no_errors():
    assert isinstance(process_trading_hours(trading_hours_string), list)


def test_process_trading_hours():
    """
    Output generated by `proces_trading_hours` in Eastern compared to
    output given in UTC.
    """
    output = [
        (
            datetime(2023, 10, 16, 17, 00, tzinfo=timezone.utc),
            datetime(2023, 10, 17, 16, 00, tzinfo=timezone.utc),
        ),
        (
            datetime(2023, 10, 17, 17, 00, tzinfo=timezone.utc),
            datetime(2023, 10, 18, 16, 00, tzinfo=timezone.utc),
        ),
        (
            datetime(2023, 10, 18, 17, 00, tzinfo=timezone.utc),
            datetime(2023, 10, 19, 16, 00, tzinfo=timezone.utc),
        ),
        (
            datetime(2023, 10, 19, 17, 00, tzinfo=timezone.utc),
            datetime(2023, 10, 20, 16, 00, tzinfo=timezone.utc),
        ),
        # non trading day is just skipped
        (
            datetime(2023, 10, 22, 17, 00, tzinfo=timezone.utc),
            datetime(2023, 10, 23, 16, 00, tzinfo=timezone.utc),
        ),
    ]
    assert (
        process_trading_hours(
            trading_hours_string, input_tz="UTC", output_tz="US/Eastern"
        )
        == output
    )


@pytest.mark.parametrize(
    "datetimetuple,result",
    [
        ((2023, 10, 16, 17, 15), True),  # from first tuple
        ((2023, 10, 17, 20, 15), True),  # from non-first tuple
        ((2023, 10, 17, 16, 30), False),  # during daily off hours
        ((2023, 10, 21, 17, 15), False),  # during closed day]
    ],
)
def test_is_active(datetimetuple: tuple[int, int, int, int, int], result: bool):
    # hours output in UTC, which compares correctly with now given in US/Central
    hours = process_trading_hours(trading_hours_string, input_tz="US/Central")
    now = datetime(*datetimetuple, tzinfo=ZoneInfo("US/Central"))
    assert is_active(hours, now=now) == result


@pytest.mark.parametrize(
    "datetimetuple,result",
    [
        (
            (2023, 10, 16, 17, 15),
            (2023, 10, 17, 17, 00),
        ),  # from first tuple, market is active
        (
            (2023, 10, 17, 20, 15),
            (2023, 10, 18, 17, 00),
        ),  # from non-first tuple, market is active
        ((2023, 10, 17, 16, 30), (2023, 10, 17, 17, 00)),  # during daily off hours
        ((2023, 10, 21, 17, 15), (2023, 10, 22, 17, 00)),  # during closed day]
    ],
)
def test_next_active(
    datetimetuple: tuple[int, int, int, int, int],
    result: tuple[int, int, int, int, int],
):
    hours = process_trading_hours(
        trading_hours_string,
    )
    now = datetime(*datetimetuple, tzinfo=ZoneInfo("US/Central"))
    assert next_active(hours, now=now) == datetime(
        *result, tzinfo=ZoneInfo("US/Central")
    )


def test_process_trading_hours_accepts_empty_string():
    # this is what IB returns for an expired contract
    assert isinstance(process_trading_hours("", ""), list)


def test_is_active_for_expired_contract():
    trading_hours = process_trading_hours("", input_tz="")
    assert is_active(trading_hours) is False


def test_process_trading_hours_for_expired_contracts():
    assert process_trading_hours("", "") == []


def test_next_active_for_expired_contracts():
    trading_hours = process_trading_hours("", input_tz="")
    assert next_active(trading_hours) is None


@pytest.mark.parametrize(
    "contract",
    [
        ibi.Stock,
        ibi.Option,
        ibi.Future,
        ibi.ContFuture,
        ibi.Index,
        ibi.CFD,
        ibi.Bond,
        ibi.Commodity,
        ibi.FuturesOption,
        ibi.MutualFund,
        ibi.Warrant,
        ibi.Crypto,
    ],
)
def test_contractAsTuple_works_for_every_contract_type_except_for_bag(contract):
    tuples = contractAsTuple(contract())
    assert isinstance(tuples, tuple)
    assert isinstance(tuples[0], tuple)


def test_hash_contract():
    # test if result hashable
    hash(hash_contract(ibi.ContFuture("NQ", "CME")))


def test_general_to_specific_contract_class():
    contract = ibi.Contract(
        secType="FUT",
        conId=657106382,
        symbol="HSI",
        lastTradeDateOrContractMonth="20240130",
        multiplier="50",
        exchange="HKFE",
        currency="HKD",
        localSymbol="HSIF4",
        tradingClass="HSI",
    )
    future = general_to_specific_contract_class(contract)

    assert future == contract
    assert isinstance(future, ibi.Future)


def test_general_to_specific_contract_class_with_contfuture():
    contract = ibi.ContFuture(
        conId=656780482,
        symbol="MGC",
        lastTradeDateOrContractMonth="20250827",
        multiplier="10",
        exchange="COMEX",
        currency="USD",
        localSymbol="MGCQ5",
        tradingClass="MGC",
    )
    future = general_to_specific_contract_class(contract)

    assert future == contract
    assert isinstance(future, ibi.Future)


def test_general_to_specific_contract_class_with_contfuture_Contract():
    contract = ibi.Contract(
        secType="CONTFUT",
        conId=674701641,
        symbol="MGC",
        lastTradeDateOrContractMonth="20251229",
        multiplier="10",
        exchange="COMEX",
        currency="USD",
        localSymbol="MGCZ5",
        tradingClass="MGC",
    )

    future = general_to_specific_contract_class(contract)

    assert future == contract
    assert isinstance(future, ibi.Future)


def test_general_to_specific_contract_class_works_with_non_futures():
    contract = ibi.Contract(
        secType="STK",
        conId=4391,
        symbol="AMD",
        exchange="SMART",
        primaryExchange="NASDAQ",
        currency="USD",
        localSymbol="AMD",
        tradingClass="NMS",
        comboLegs=[],
    )

    modified = general_to_specific_contract_class(contract)

    assert modified == contract
    assert isinstance(modified, ibi.Stock)


def test_general_to_specific_contract_class_doesnt_touch_contract_subclasses():
    contract = ibi.Future(
        conId=637533641,
        symbol="ES",
        lastTradeDateOrContractMonth="20250919",
        multiplier="50",
        exchange="CME",
        currency="USD",
        localSymbol="ESU5",
        tradingClass="ES",
    )
    future = general_to_specific_contract_class(contract)
    assert future is contract


def test_general_to_specific_contract_class_raises_with_non_contracts():
    some_faulty_object = object()
    with pytest.raises(AssertionError):
        general_to_specific_contract_class(some_faulty_object)
