import asyncio
from unittest.mock import Mock

import eventkit as ev  # type: ignore
import pytest

from haymaker.logging import setup_asyncio_logger


@pytest.mark.asyncio
async def test_asyncio_exception_handler_with_eventkit_event(caplog):
    # this proves that eventkit logs even without setting custom handler
    # asyncio loop

    event = ev.Event()

    class MyError(Exception):
        pass

    async def failing_coroutine(*args):
        raise MyError("This is the error.")

    event += failing_coroutine

    event.emit()
    await asyncio.sleep(0.001)
    assert any("This is the error" in record.message for record in caplog.records)
    assert any(record.levelname == "ERROR" for record in caplog.records)


@pytest.mark.asyncio
async def test_asyncio_exception_handler_with_eventkit_event_and_asyncio_handler(
    caplog,
):
    # make sure errors are not logged twice
    setup_asyncio_logger()
    event = ev.Event()

    class MyError(Exception):
        pass

    async def failing_coroutine(*args):
        raise MyError("This is the error.")

    event += failing_coroutine

    event.emit()
    await asyncio.sleep(0.001)
    assert len(caplog.records) == 1


# #################################
# These are generated by llm
# #################################


def test_asyncio_exception_handler_with_exception_and_task():
    """Test handler with a full exception and task."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()
    loop = Mock()
    test_exception = ValueError("Test error")
    mock_task = Mock()
    mock_task.get_name.return_value = "test-task"
    mock_task.__repr__ = Mock(return_value="<Task test-task>")

    context = {
        "message": "Task exception was never retrieved",
        "exception": test_exception,
        "task": mock_task,
    }

    asyncio_exception_handler(loop, context, logger=mock_logger)

    # Check that error was called with exc_info
    mock_logger.error.assert_called_once()
    call_args = mock_logger.error.call_args

    # Check the error message contains expected parts
    error_message = call_args[0][0]
    assert "Asyncio exception: Task exception was never retrieved" in error_message
    assert "Task: test-task" in error_message
    assert "Task repr: <Task test-task>" in error_message
    assert f"Exception: {test_exception!r}" in error_message

    # Check exc_info was passed
    assert call_args[1]["exc_info"] == test_exception


def test_asyncio_exception_handler_with_source_traceback():
    """Test handler includes source traceback when available."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()
    loop = Mock()
    test_exception = RuntimeError("Test error")
    mock_task = Mock()
    mock_task.get_name.return_value = "traced-task"

    # Create fake traceback
    fake_tb = [
        ("file.py", 10, "function_name", "some_code()"),
        ("other.py", 20, "other_function", "other_code()"),
    ]

    context = {
        "message": "Test message",
        "exception": test_exception,
        "task": mock_task,
        "source_traceback": fake_tb,
    }

    asyncio_exception_handler(loop, context, logger=mock_logger)

    error_message = mock_logger.error.call_args[0][0]
    assert "Task was created at:" in error_message
    assert "file.py" in error_message


def test_asyncio_exception_handler_with_future_instead_of_task():
    """Test handler works with 'future' key instead of 'task'."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()
    loop = Mock()
    test_exception = KeyError("missing_key")
    mock_future = Mock()
    mock_future.get_name.return_value = "future-1"

    context = {
        "message": "Future exception",
        "exception": test_exception,
        "future": mock_future,
    }

    asyncio_exception_handler(loop, context, logger=mock_logger)

    error_message = mock_logger.error.call_args[0][0]
    assert "Task: future-1" in error_message
    mock_logger.error.assert_called_once()


def test_asyncio_exception_handler_without_exception_object():
    """Test handler when no exception object is present."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()
    loop = Mock()

    context = {
        "message": "Some error without exception object",
        "other_info": "additional context",
    }

    asyncio_exception_handler(loop, context, logger=mock_logger)

    error_message = mock_logger.error.call_args[0][0]
    assert "Some error without exception object" in error_message
    assert "Full context:" in error_message
    assert "other_info" in error_message

    # Should NOT have exc_info
    assert "exc_info" not in mock_logger.error.call_args[1]


def test_asyncio_exception_handler_with_unnamed_task():
    """Test handler with task that has no get_name method."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()
    loop = Mock()
    test_exception = Exception("Test")
    mock_task = Mock(spec=[])  # No get_name method

    context = {
        "exception": test_exception,
        "task": mock_task,
    }

    asyncio_exception_handler(loop, context, logger=mock_logger)

    error_message = mock_logger.error.call_args[0][0]
    assert "Task: unnamed" in error_message


def test_asyncio_exception_handler_default_message():
    """Test handler uses default message when none provided."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()
    loop = Mock()
    test_exception = ValueError("error")

    context = {
        "exception": test_exception,
    }

    asyncio_exception_handler(loop, context, logger=mock_logger)

    error_message = mock_logger.error.call_args[0][0]
    assert "Unhandled exception in async task" in error_message


@pytest.mark.asyncio
async def test_asyncio_exception_handler_integration_with_real_task():
    """Integration test simulating a real task exception."""
    from haymaker.logging.asyncio_exception_handler import asyncio_exception_handler

    mock_logger = Mock()

    # Simulate what asyncio would pass to the exception handler
    async def failing_task():
        raise RuntimeError("Real task failure")

    # Create the task
    task = asyncio.create_task(failing_task(), name="integration-test-task")

    # Wait for it to fail
    try:
        await task
    except RuntimeError:
        pass  # Expected

    # Manually call our handler with a realistic context
    # (simulating what asyncio would do)
    context = {
        "message": "Task exception was never retrieved",
        "exception": task.exception(),
        "task": task,
    }

    loop = asyncio.get_event_loop()
    asyncio_exception_handler(loop, context, logger=mock_logger)

    # Check that our handler was called correctly
    mock_logger.error.assert_called_once()
    error_message = mock_logger.error.call_args[0][0]
    assert "integration-test-task" in error_message
    assert "RuntimeError" in error_message or "Real task failure" in error_message
